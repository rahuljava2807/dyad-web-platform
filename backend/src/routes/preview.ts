import express, { Request, Response } from 'express';
import path from 'path';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';

const router = express.Router();

// Store for preview sessions (in production, use Redis or similar)
const previewSessions = new Map<string, { files: any[]; createdAt: Date }>();

/**
 * Generate Preview
 * POST /api/preview/generate
 */
router.post('/generate', async (req: Request, res: Response) => {
  const { files } = req.body;

  if (!files || !Array.isArray(files)) {
    return res.status(400).json({ error: 'Files array is required' });
  }

  try {
    // Create a unique session ID
    const sessionId = uuidv4();

    // Store files for this session
    previewSessions.set(sessionId, {
      files,
      createdAt: new Date()
    });

    // Generate preview URL
    const previewUrl = `/api/preview/${sessionId}`;

    res.json({
      sessionId,
      url: previewUrl,
      expiresIn: 3600 // 1 hour
    });
  } catch (error) {
    console.error('Preview generation error:', error);
    res.status(500).json({ error: 'Failed to generate preview' });
  }
});

/**
 * Serve Preview
 * GET /api/preview/:sessionId
 */
router.get('/:sessionId', async (req: Request, res: Response) => {
  const { sessionId } = req.params;

  const session = previewSessions.get(sessionId);

  if (!session) {
    return res.status(404).send('Preview not found or expired');
  }

  try {
    // Build HTML preview
    const html = buildPreviewHTML(session.files);

    res.setHeader('Content-Type', 'text/html');
    res.send(html);
  } catch (error) {
    console.error('Preview serving error:', error);
    res.status(500).send('Failed to load preview');
  }
});

/**
 * Get Preview Files
 * GET /api/preview/:sessionId/files
 */
router.get('/:sessionId/files', async (req: Request, res: Response) => {
  const { sessionId } = req.params;

  const session = previewSessions.get(sessionId);

  if (!session) {
    return res.status(404).json({ error: 'Preview not found or expired' });
  }

  res.json({ files: session.files });
});

/**
 * Build HTML preview from files
 */
function buildPreviewHTML(files: any[]): string {
  // Find the main entry point
  const entryFile = files.find(f => f.path === '/src/app/page.tsx' || f.path === '/src/app/page.jsx');

  if (!entryFile) {
    return buildErrorHTML('No entry point found. Expected /src/app/page.tsx');
  }

  // Escape the component code for embedding in HTML
  const escapedCode = entryFile.content
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$');

  // Build complete HTML with React and Recharts CDN
  return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Preview - Generated by Yavi Studio</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/recharts@2.5.0/umd/Recharts.js"></script>
  <script src="https://unpkg.com/framer-motion@11.0.0/dist/framer-motion.js"></script>
  <style>
    body { margin: 0; padding: 0; font-family: Inter, system-ui, sans-serif; }
    #root { min-height: 100vh; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    // Make React and ReactDOM globally available
    window.React = React;
    window.ReactDOM = ReactDOM;
    window.Recharts = Recharts;
    window.FramerMotion = {
      motion: {
        div: React.createElement.bind(React, 'div'),
        span: React.createElement.bind(React, 'span'),
        h1: React.createElement.bind(React, 'h1'),
        h2: React.createElement.bind(React, 'h2'),
        h3: React.createElement.bind(React, 'h3'),
        p: React.createElement.bind(React, 'p'),
        button: React.createElement.bind(React, 'button'),
        img: React.createElement.bind(React, 'img'),
        svg: React.createElement.bind(React, 'svg'),
        path: React.createElement.bind(React, 'path'),
        circle: React.createElement.bind(React, 'circle'),
        rect: React.createElement.bind(React, 'rect'),
        g: React.createElement.bind(React, 'g'),
        line: React.createElement.bind(React, 'line'),
        polygon: React.createElement.bind(React, 'polygon'),
        text: React.createElement.bind(React, 'text'),
        tspan: React.createElement.bind(React, 'tspan')
      },
      AnimatePresence: function({children}) { return React.createElement(React.Fragment, null, children); }
    };

    // Console log capture
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;

    console.log = function(...args) {
      originalLog.apply(console, args);
      window.parent.postMessage({ type: 'console', level: 'log', message: args.join(' ') }, '*');
    };

    console.error = function(...args) {
      originalError.apply(console, args);
      window.parent.postMessage({ type: 'console', level: 'error', message: args.join(' ') }, '*');
    };

    console.warn = function(...args) {
      originalWarn.apply(console, args);
      window.parent.postMessage({ type: 'console', level: 'warning', message: args.join(' ') }, '*');
    };

    // Error handling
    window.onerror = function(message, source, lineno, colno, error) {
      window.parent.postMessage({
        type: 'console',
        level: 'error',
        message: \`Error: \${message} at \${source}:\${lineno}:\${colno}\`
      }, '*');
      return true;
    };

    // Unhandled promise rejections
    window.addEventListener('unhandledrejection', function(event) {
      window.parent.postMessage({
        type: 'console',
        level: 'error',
        message: \`Unhandled Promise Rejection: \${event.reason}\`
      }, '*');
    });

    // Execute the component code
    try {
      const componentCode = \`${escapedCode}\`;
      eval(componentCode);
      
      // Render the component
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    } catch (error) {
      console.error('Error rendering component:', error);
      document.getElementById('root').innerHTML = '<div class="p-8"><h1 class="text-2xl font-bold text-red-600">Error rendering component</h1><p class="text-gray-600">' + error.message + '</p></div>';
    }
  </script>
</body>
</html>
  `.trim();
}

/**
 * Extract JSX content from React component
 */
function extractComponentContent(code: string): string {
  try {
    console.log('Extracting from code:', code);
    
    // Try to find the return statement with better regex
    const returnMatch = code.match(/return\s*\(([\s\S]*?)\)\s*;?\s*}/);
    console.log('Return match:', returnMatch);
    
    if (returnMatch) {
      let jsx = returnMatch[1].trim();
      console.log('Extracted JSX:', jsx);
      
      // Handle template literals and expressions
      jsx = jsx.replace(/\$\{[^}]+\}/g, (match) => {
        // Replace with placeholder text
        return match.replace(/\$\{|\}/g, '').trim() || 'dynamic content';
      });
      
      // Clean up JSX for HTML
      jsx = jsx.replace(/className=/g, 'class=');
      jsx = jsx.replace(/\{\/\*[\s\S]*?\*\/\}/g, ''); // Remove comments
      jsx = jsx.replace(/\{([^}]+)\}/g, (match, content) => {
        // Handle JSX expressions
        return content.trim() || 'dynamic';
      });
      
      console.log('Final JSX:', jsx);
      return jsx;
    }
    
    // Fallback: try to find JSX without return statement
    const jsxMatch = code.match(/<div[^>]*>[\s\S]*<\/div>/);
    if (jsxMatch) {
      let jsx = jsxMatch[0];
      jsx = jsx.replace(/className=/g, 'class=');
      jsx = jsx.replace(/\$\{[^}]+\}/g, 'dynamic');
      jsx = jsx.replace(/\{([^}]+)\}/g, (match, content) => {
        return content.trim() || 'dynamic';
      });
      return jsx;
    }
    
  } catch (error) {
    console.error('Error extracting component:', error);
  }

  console.log('Failed to extract JSX, returning error message');
  return '<div class="p-8"><h1 class="text-2xl font-bold">Unable to render preview</h1></div>';
}

/**
 * Build error HTML
 */
function buildErrorHTML(message: string): string {
  return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Preview Error</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
  <div class="min-h-screen flex items-center justify-center p-4">
    <div class="bg-white rounded-lg shadow-lg p-8 max-w-md">
      <div class="text-red-600 text-6xl mb-4">⚠️</div>
      <h1 class="text-2xl font-bold text-gray-900 mb-2">Preview Error</h1>
      <p class="text-gray-600">${message}</p>
    </div>
  </div>
</body>
</html>
  `.trim();
}

/**
 * Cleanup old sessions (run periodically)
 */
setInterval(() => {
  const now = new Date();
  const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);

  for (const [sessionId, session] of previewSessions.entries()) {
    if (session.createdAt < oneHourAgo) {
      previewSessions.delete(sessionId);
    }
  }
}, 5 * 60 * 1000); // Run every 5 minutes

export default router;
